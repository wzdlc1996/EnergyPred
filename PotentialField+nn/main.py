# -*- coding: utf-8 -*-

import net
import torch
import numpy as np
import copy

# Load the data generated by Mathematica code
x = np.loadtxt("./data/data_mat/dataTrain.dat")
y = np.loadtxt("./data/data_mat/valuTrain.dat")
x_val = np.loadtxt("./data/data_mat/dataVali.dat")
y_val = np.loadtxt("./data/data_mat/valuVali.dat")

x = torch.as_tensor(x, dtype=torch.float32)
y = torch.as_tensor(y, dtype=torch.float32).reshape(len(y),1)
x_val = torch.as_tensor(x_val, dtype=torch.float32)
y_val = torch.as_tensor(y_val, dtype=torch.float32).reshape(len(y_val), 1)

device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")

# Move data to GPU if cuda device is avalibale
x = x.to(device)
y = y.to(device)
x_val = x_val.to(device)
y_val = y_val.to(device)

model = net.energyRegNet()
model.to(device)

lossFunc = torch.nn.MSELoss().to(device)
trainLoss = torch.nn.MSELoss().to(device)

# Initial learning rate
learR = 1e-5
optimizer = torch.optim.Adam(model.parameters(), lr=learR)

# Initial the loss value
lossReg = 1.

# Error list, used in the automatically adjust the learning rate
errlis = np.zeros(100)

# Begin the training
model.train()
for t in range(50000):
    ypred = model(x)
    loss = trainLoss(ypred, y)
    
    # Print the loss after each epoch
    print(t, loss.item())
    
    # If there is no imporvement on training set after 100 epochs, half the learning rate
    if t > 100 and t % 100 == 0 and np.average(errlis[-50:]) > np.average(errlis[:50]):
        learR /= 2
        optimizer = torch.optim.Adam(model.parameters(), lr=learR)
        print("update learning rate, now is: "+str(learR))
    errlis[t % 100] = loss.item()
    
    # Print the performance on validation set ever 25 epochs
    if(t % 25 == 0):
        model.eval()
        tmpy = model.forward(x_val)
        losstmp = np.sqrt(lossFunc(tmpy, y_val).item())
        
        # Save the best model
        if losstmp < lossReg:
            modelReg = copy.deepcopy(model)
            lossReg = losstmp
            torch.save(modelReg, "./model.pt")
        print("the "+str(t)+"-th training result is: "+str(losstmp))
        model.train()
    
    optimizer.zero_grad()
    loss.backward()
    optimizer.step()

torch.save(modelReg, "./model_mat.pt")

modelReg.eval()

# Compute the test value.
test = np.loadtxt("../data_mat/dataTest.dat")
test = torch.as_tensor(test, dtype = torch.float32).to(device)

testval = modelReg(test)

with open("./resTest.dat", "w") as f:
    f.write("Id,Predicted\n")
    ind = 1
    for tv in testval:
        f.write(str(ind) + ",\t" + str(tv.item())+"\n")
        ind += 1